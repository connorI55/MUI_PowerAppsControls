/**
 * @fileoverview Rule to disallow certain object properties that is customizable
 * @description This is somewhat of a variation of the original eslint rule, no-restricted-properties,
 * in a manner that allows rules that extend using eslint-rule-composer. This is
 * necessary because the underlying options object is frozen by eslint.
 */

"use strict";

const ruleUtils = require("./rule-utils");

//----------------------------------------------------------------------
// Helpers
//----------------------------------------------------------------------

function dereferenceMember(logic, node) {
    var result = "";
    if (node.type === "MemberExpression" || node.type === "Identifier") {
        const objectName = node.object ? node.object.name : node.name;
        const value = logic.memberVariables[objectName];
        result = logic.sourceCode.getText(node);
        // Adding temporary objectName requirement to avoid an undefined when destructuring patterns are present
        // This should be investigated in the future as ESLint should be able to parse this destructuring pattern
        // e.g., https://eslint.org/docs/rules/prefer-destructuring
        if (value && objectName) {
            result = value + result.substring(objectName.length);
        }
    }
    return result;
}

/**
 * Assumes that the name param value passed is a fully qualified object name
 * and looks in the list of restricted objects for a match.
 * @param {string} name - fully qualified object name in which to compare.
 */
function isRestrictedObject(logic, name) {
    let strippedDownName = ruleUtils.getExpressionWithoutParens(name);
    for (var i = 0; i < logic.restrictedCalls.length; i++) {
        // Take out window and parent, if we want to report on issue with them as root level objects.
        if (logic.restrictedCalls[i].object !== undefined
            && (logic.restrictedCalls[i].object.startsWith(strippedDownName)
                || (logic.restrictedCalls[i].disallowParent && logic.restrictedCalls[i].object.startsWith(ruleUtils.removeWindowReferences(strippedDownName))))) {
            return true;
        }
    }
    return false;
}

/**
 * Assumes that the name param value passed is a fully qualified property with the object name included
 * and looks in the list of restricted objects for a match including the object and property.
 * @param {string} name - fully qualified property name in which to compare.
 */
function isRestrictedProperty(logic, name) {
    let strippedDownName = ruleUtils.getExpressionWithoutParens(name);
    for (var i = 0; i < logic.restrictedCalls.length; i++) {
        if (logic.restrictedCalls[i].object !== undefined && logic.restrictedCalls[i].property !== undefined) {
            let fullyQualifiedPropertyName = logic.restrictedCalls[i].object + '.' + logic.restrictedCalls[i].property;
            if (fullyQualifiedPropertyName.startsWith(strippedDownName)
                || (logic.restrictedCalls[i].disallowParent && logic.restrictedCalls[i].object.startsWith(ruleUtils.removeWindowReferences(strippedDownName)))) {
                return true;
            }
        }
    }
    return false;
}

function tryReportTargetExpression(logic, node, expression) {
    const expressionParts = expression.split('.');
    const expressionMinusParent = ruleUtils.removeWindowReferences(expression);
    const expressPartsMinusParent = expressionMinusParent.split('.');

    // Get the object with namespace, fully qualified, if there is an object.
    let objectName = expressionParts.length >= 2 ? expressionParts.slice(0, expressionParts.length - 1).join('.') : undefined;
    objectName = ruleUtils.getExpressionWithoutParens(objectName);
    
    let objectNameMinusParent = expressPartsMinusParent.length >= 2 ? expressPartsMinusParent.slice(0, expressPartsMinusParent.length - 1).join('.') : undefined;
    objectNameMinusParent = ruleUtils.getExpressionWithoutParens(objectNameMinusParent);
    
    // Get the last element. We want unqualified object.
    const propertyName = expressionParts.pop();

    const matchedObject = logic.restrictedProperties.get(objectName);
    const matchedObjectMinusParent = logic.restrictedProperties.get(objectNameMinusParent);

    
    let matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : logic.globallyRestrictedObjects.get(objectName);
    let matchedObjectPropertyMinusParent = matchedObjectMinusParent ? matchedObjectMinusParent.get(propertyName) : logic.globallyRestrictedObjects.get(matchedObjectMinusParent);

    // Try with the fully qualified name, if not found split apart.
    matchedObjectProperty = matchedObjectProperty ? matchedObjectProperty : logic.globallyRestrictedObjects.get(expression);
    matchedObjectPropertyMinusParent = matchedObjectPropertyMinusParent ? matchedObjectPropertyMinusParent : logic.globallyRestrictedObjects.get(expressionMinusParent);

    const globalMatchedProperty = logic.globallyRestrictedProperties.get(propertyName);

    if (matchedObjectProperty) {
        const messageId = matchedObjectProperty.messageId ? `${matchedObjectProperty.messageId}` : "";
        if (logic.reporter && (typeof logic.reporter === "function")) {
            logic.reporter(
                logic.context,
                node,
                true,
                {
                    objectName,
                    propertyName,
                    messageId
                },
                expression
            );
            return true;
        }
    }
    else if (matchedObjectPropertyMinusParent && matchedObjectPropertyMinusParent.disallowParent) {
        const messageId = matchedObjectPropertyMinusParent.messageId ? `${matchedObjectPropertyMinusParent.messageId}` : "";
        if (logic.reporter && (typeof logic.reporter === "function")) {
            logic.reporter(
                logic.context,
                node,
                true,
                {
                    objectName,
                    propertyName,
                    messageId
                },
                expression
            );
            return true;
        }
    }
    else if (globalMatchedProperty) {
        const messageId = globalMatchedProperty.messageId ? `${globalMatchedProperty.messageId}` : "";
        if (logic.reporter && (typeof logic.reporter === "function")) {
            logic.reporter(
                logic.context,
                node,
                false,
                {
                    propertyName,
                    messageId
                },
                expression
            );
            return true;
        }
    }

    return false;
}

class noRestrictedProperties {
    constructor(context, optionsOverride, reporter) {
        this.context = context;
        this.reporter = reporter;
        this.restrictedCalls = (typeof (optionsOverride) === "undefined" || optionsOverride.length < 0)
            ? context.options
            : optionsOverride;
        if (this.restrictedCalls.length === 0) {
            return {};
        }
        this.sourceCode = context.getSourceCode();
        this.restrictedProperties = new Map();
        this.globallyRestrictedObjects = new Map();
        this.globallyRestrictedProperties = new Map();
        this.memberVariables = {};
        // Create restricted lists at multiple levels with a hierarchy that are easier to search through.
        this.restrictedCalls.forEach(option => {
            const objectName = option.object;
            const propertyName = option.property;
            if (typeof objectName === "undefined") {
                this.globallyRestrictedProperties.set(propertyName, { messageId: option.messageId, disallowParent: option.disallowParent });
            }
            else if (typeof propertyName === "undefined") {
                this.globallyRestrictedObjects.set(objectName, { messageId: option.messageId, disallowParent: option.disallowParent });
            }
            else {
                if (!this.restrictedProperties.has(objectName)) {
                    this.restrictedProperties.set(objectName, new Map());
                }
                this.restrictedProperties.get(objectName).set(propertyName, { messageId: option.messageId, disallowParent: option.disallowParent });
            }
        });

        return this;
    }

    processVariableDeclarator(node) {
        if (node.init) {
            let resolvedName = "";
            
            if (node.init.type === "MemberExpression") {
                resolvedName = dereferenceMember(this, node.init);
            }
            if (resolvedName === "") {
                // Either we couldn't deref, or the right side is a CallExpression
                resolvedName = this.sourceCode.getText(node.init);
            }
            // Check to see if this is a variable assigned to an object or a property.
            if (isRestrictedObject(this, resolvedName) || isRestrictedProperty(this, resolvedName)) {
                this.memberVariables[node.id.name] = resolvedName;
            }
        }
    }

    processMemberExpression(node) {
        let exprText = this.sourceCode.getText(node);
        // First check for a fully-qualified match
        if (!tryReportTargetExpression(this, node, exprText)) {
            // Next, see if we can dereference and get a match
            exprText = dereferenceMember(this, node);
            if (!tryReportTargetExpression(this, node, exprText)) {

            }
        }
    }
}

module.exports = noRestrictedProperties;