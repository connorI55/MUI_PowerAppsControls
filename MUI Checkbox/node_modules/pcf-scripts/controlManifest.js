"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlManifest = void 0;
/// <reference path="../../common/typings/controlmanifest.d.ts"/>
const { Builder } = require('xml2js');
const flatMap = require('lodash/flatMap');
const constants = require("./constants");
const lodash_1 = require("lodash");
class ControlManifest {
    constructor(manifestObj) {
        this.data = manifestObj;
    }
    getControlVersion() {
        return this.data.manifest.control.$.version;
    }
    setControlVersion(newVersion) {
        this.data.manifest.control.$.version = newVersion;
    }
    getManifestData() {
        return this.data;
    }
    getNamespace() {
        return this.data.manifest.control.$.namespace;
    }
    getConstructor() {
        return this.data.manifest.control.$.constructor;
    }
    getCodePath() {
        return this.data.manifest.control.resources[constants.CODE_ELEM_NAME][0].$.path;
    }
    getPreviewImagePath() {
        return this.data.manifest.control.$['preview-image'];
    }
    getDesignMapsFilePath() {
        return this.data.manifest.control.$['design-mapping-file'];
    }
    // Return an array of paths of the control's resources relative to that control's root folder
    // includeTs flag determines whether <code> element's path will be included
    getResources(includeTs) {
        const resources = this.data.manifest.control.resources;
        let pathsCollection = [];
        Object.keys(resources)
            .filter((resourceType) => resourceType !== constants.PLATFORM_LIBRARY_ELEM_NAME && resourceType !== constants.RES_DEPENDENCY_ELEM_NAME)
            .forEach(resourceType => {
            let paths;
            if (resourceType !== constants.LIBRARY_ELEM_NAME) {
                paths = (resourceType === constants.CODE_ELEM_NAME && !includeTs) ? [] : resources[resourceType].map((resource) => resource.$.path);
            }
            else {
                paths = flatMap(resources[resourceType], (resource) => resource['packaged_library'] ? resource['packaged_library'].map((packagedLib) => packagedLib.$.path) : []);
            }
            pathsCollection.push(...paths);
        });
        return pathsCollection;
    }
    // Build xml string from the ControlManifest's json object
    getManifestXmlString() {
        const clonedData = this.removeOutputDirectoryAttr();
        const jsonToXmlbuilder = new Builder();
        const xml = jsonToXmlbuilder.buildObject(clonedData);
        return xml;
    }
    removeOutputDirectoryAttr() {
        const clonedData = (0, lodash_1.cloneDeep)(this.data);
        const clonedResources = (0, lodash_1.cloneDeep)(this.data.manifest.control.resources);
        Object.keys(clonedResources).forEach(resourceType => {
            clonedResources[resourceType].forEach((resource) => {
                var _a, _b;
                if (resourceType === constants.LIBRARY_ELEM_NAME) {
                    (_a = resource['packaged_library']) === null || _a === void 0 ? void 0 : _a.forEach((packagedLib) => {
                        if (packagedLib.$.outputDirectory) {
                            delete packagedLib.$.outputDirectory;
                        }
                    });
                }
                else if ((_b = resource.$) === null || _b === void 0 ? void 0 : _b.outputDirectory) {
                    delete resource.$.outputDirectory;
                }
            });
        });
        clonedData.manifest.control.resources = clonedResources;
        return clonedData;
    }
}
exports.ControlManifest = ControlManifest;

//# sourceMappingURL=controlManifest.js.map
