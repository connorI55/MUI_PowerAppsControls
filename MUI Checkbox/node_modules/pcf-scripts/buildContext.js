"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildContext = void 0;
/// <reference path="./typings/buildConfig.d.ts"/>
const fs = require('fs');
const path = require('path');
const controlContext_1 = require("./controlContext");
const constants = require("./constants");
const diagnosticMessages_generated_1 = require("./diagnosticMessages.generated");
const designContext_1 = require("./designContext");
const featureManager_1 = require("./featureManager");
// Context for building PCF controls
class BuildContext {
    constructor(diag, config) {
        this.config = config;
        this._diag = diag;
        this._featureManager = new featureManager_1.FeatureManager();
        if (config.controlsRoot) {
            this.controls = this.getControls();
        }
        if (this._featureManager.isFeatureEnabled('pcfTheming')) {
            this.designMapContext = this.getDesignContexts();
        }
    }
    // Gets the controls root directory
    getControlsRoot() {
        return this.config.controlsRoot;
    }
    // Gets the output directory
    getOutDir() {
        return this.config.outDir;
    }
    // Gets the build mode
    getBuildMode() {
        return this.config.buildMode;
    }
    // Gets the locale
    getLocale() {
        return this.config.locale;
    }
    // Gets the diagnostic manager
    getDiagnostic() {
        return this._diag;
    }
    getDesignContexts() {
        var _a, _b;
        return (_b = (_a = this.controls) === null || _a === void 0 ? void 0 : _a.filter((control) => this.isThemedControl(control))) === null || _b === void 0 ? void 0 : _b.map(control => {
            return new designContext_1.DesignContext(this._diag, control);
        });
    }
    // Maps the specified callback for each control under the root directory
    mapControls(callback) {
        if (!this.config.controlsRoot) {
            this._diag.pushA(diagnosticMessages_generated_1.strings.buildconfig_not_defined, ['controlsRoot']);
            return Promise.reject();
        }
        if (!this.controls || this.controls.length === 0) {
            this._diag.pushA(diagnosticMessages_generated_1.strings.control_manifest_not_found, [constants.MANIFEST_INPUT_FILE_NAME]);
            return Promise.reject();
        }
        const results = this.controls.map((value) => { return callback(value); });
        return Promise.all(results);
    }
    // maps the specified callback for each design map under the control root
    mapDesignFile(callback) {
        var _a;
        if (this.needsToProcessAsStandardControl()) {
            this._diag.push(diagnosticMessages_generated_1.strings.processing_as_standard_control);
            return Promise.resolve();
        }
        const results = (_a = this.designMapContext) === null || _a === void 0 ? void 0 : _a.map((value) => { return callback(value); });
        return Promise.all(results);
    }
    // Gets the list of controls under the controls root directory
    getControls() {
        if (!this.config.controlsRoot) {
            return [];
        }
        // Exclude node_modules and outdir from control folder search
        const exludedFolders = [
            path.join(this.config.controlsRoot, 'node_modules')
        ];
        if (this.config.outDir) {
            exludedFolders.push(path.join(this.config.controlsRoot, this.config.outDir));
        }
        let controls = BuildContext.findControlFolders(this.config.controlsRoot, exludedFolders);
        return controls.map((controlPath) => {
            return new controlContext_1.ControlContext(this._diag, controlPath);
        });
    }
    // Searches the provided directory for control folders.
    // A control folder is defined as containing a ControlManifest.Input.xml file.
    static findControlFolders(cwd, excludedFolders) {
        let results = [];
        if (fs.existsSync(path.join(cwd, constants.MANIFEST_INPUT_FILE_NAME))) {
            results.push(cwd);
            return results;
        }
        let folders = fs.readdirSync(cwd).filter(function (file) {
            return fs.statSync(path.join(cwd, file)).isDirectory();
        });
        folders.forEach((folder) => {
            const currentFolder = path.join(cwd, folder);
            if (excludedFolders && excludedFolders.find((elem) => elem === currentFolder)) {
                return;
            }
            else {
                results = results.concat(this.findControlFolders(currentFolder));
            }
        });
        return results;
    }
    needsToProcessAsStandardControl() {
        if (this._featureManager.isFeatureEnabled('pcfTheming')) {
            return this.controls.every((control) => !this.isThemedControl(control));
        }
        return true;
    }
    isThemedControl(control) {
        return control.getControlManifest().data.manifest.control.$['design-mapping-file'] !== undefined;
    }
}
exports.BuildContext = BuildContext;

//# sourceMappingURL=buildContext.js.map
