"use strict";
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerCommonFinalTelemetryProcessors = exports.configureTelemetryClient = exports.setupAndStartAppInsights = void 0;
var AppTelemetryUtility_1 = require("./AppTelemetryUtility");
var appInsights = require("applicationinsights");
function setupAndStartAppInsights(appInsightsResourceProvider, environment) {
    var appInsightsResource = appInsightsResourceProvider.GetAppInsightsResourceForDataBoundary(environment.dataBoundary);
    appInsights.setup(appInsightsResource.connectionString)
        // suppress confusing DNS/http warnings if AI endpoints are not reachable
        .setInternalLogging(false, false)
        .setAutoCollectExceptions(false)
        .start();
}
exports.setupAndStartAppInsights = setupAndStartAppInsights;
function configureTelemetryClient(aiClient, productName, productVersion, sessionId, environment, userSettings) {
    var _a, _b;
    if (!productName)
        throw new Error("productName must be specified.");
    if (!productVersion)
        throw new Error("productVersion must be specified.");
    if (!AppTelemetryUtility_1.isSupportedAgentProductVersion(productVersion))
        throw new Error("productVersion '" + productVersion + "' is not a supported version format.");
    if (!sessionId)
        throw new Error("sessionId must be specified.");
    aiClient.config.disableAppInsights = (_a = environment.optOut) !== null && _a !== void 0 ? _a : !((_b = userSettings.telemetryEnabled) !== null && _b !== void 0 ? _b : true);
    // aka: ClientAppTelemetryInitializer.cs
    aiClient.context.tags[aiClient.context.keys.userId] = userSettings.uniqueId;
    aiClient.context.tags[aiClient.context.keys.cloudRole] = productName;
    aiClient.context.tags[aiClient.context.keys.cloudRoleInstance] = '#####';
    aiClient.context.tags[aiClient.context.keys.applicationVersion] = productVersion;
    aiClient.context.tags[aiClient.context.keys.sessionId] = sessionId;
}
exports.configureTelemetryClient = configureTelemetryClient;
function registerCommonFinalTelemetryProcessors(aiClient, environment, logger) {
    if (logger && !!environment.developerMode) {
        aiClient.addTelemetryProcessor(function (envelope, context) { return logTelemetryItem(logger, envelope, context); });
    }
}
exports.registerCommonFinalTelemetryProcessors = registerCommonFinalTelemetryProcessors;
function logTelemetryItem(logger, envelope, context) {
    if (!envelope.data || !logger)
        return true; // Ignore when data doesn't exist
    var telemetryType = appInsights.Contracts.baseTypeToTelemetryType(envelope.data.baseType);
    switch (telemetryType) {
        case appInsights.Contracts.TelemetryType.Request:
            {
                var data = envelope.data.baseData;
                logger.info("[pp-tooling-telemetry-node] Processing telemetry item of type '" + envelope.data.baseType + "'. name: " + data.name + ", responseCode: " + data.responseCode);
            }
            break;
        case appInsights.Contracts.TelemetryType.Event:
            {
                var data = envelope.data.baseData;
                logger.info("[pp-tooling-telemetry-node] Processing telemetry item of type '" + envelope.data.baseType + "'. name: " + data.name);
            }
            break;
        case appInsights.Contracts.TelemetryType.Exception:
            {
                var data = envelope.data.baseData;
                logger.info("[pp-tooling-telemetry-node] Processing telemetry item of type '" + envelope.data.baseType + "'. problemId: '" + data.problemId + "'");
            }
            break;
        default:
            logger.info("[pp-tooling-telemetry-node] Processing telemetry item of type '" + envelope.data.baseType + "'");
            break;
    }
    return true;
}
